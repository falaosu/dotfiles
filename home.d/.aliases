#!/usr/bin/env bash
# shellcheck disable=SC2139
# ~/.aliases

# -- Functions -------------------------------------------------------------------

# Enable colored man
# The end \ in the end of each line helps set environment variable
# to command man.
#    https://wiki.archlinux.org/index.php/Color_output_in_console#Using_less
man() {
  LESS_TERMCAP_md=$'\e[01;31m' \
  LESS_TERMCAP_me=$'\e[0m' \
  LESS_TERMCAP_se=$'\e[0m' \
  LESS_TERMCAP_so=$'\e[01;44;33m' \
  LESS_TERMCAP_ue=$'\e[0m' \
  LESS_TERMCAP_us=$'\e[01;32m' \
  command man "$@"
}

if m_check_exist vmhgfs-fuse; then
  # Usage: vmmount /path/to/mount/point
  vmmount() {
    local sharedir
    sharedir=$(vmware-hgfsclient)
    vmhgfs-fuse -o allow_other -o auto_unmount .host:"$sharedir" "$1"
  }
fi

# Usage: extract <file>
# Description: extracts archived files / mounts disk images
# Note: .dmg/hdiutil is macOS-specific.
#
# Credit: http://nparikh.org/notes/zshrc.txt
extract() {
  if [[ -f "$1" ]]; then
    local lowername
    lowername=$(printf '%s' "$1" | tr '[:upper:]' '[:lower:]')
    case "${lowername}" in
    *.tar       | *.x     ) tar -xvf        "$1" ;;
    *.tar.bz2   | *.tbz2  ) tar -jxvf       "$1" ;;
    *.tar.xz              ) tar -Jxvf       "$1" ;;
    *.tar.gz    | *.tgz   ) tar -zxvf       "$1" ;;
    *.tar.lzma            ) tar --lzma -xvf "$1" ;;
    *.bz2                 ) bunzip2         "$1" ;;
    *.xz                  ) unxz            "$1" ;;
    *.gz                  ) gunzip -k       "$1" ;;
    *.zip                 ) unzip           "$1" ;;
    *.rar                 ) unrar x         "$1" ;;
    *.7z                  ) 7z e            "$1" ;;
    *.z                   ) uncompress      "$1" ;;
    *                     ) echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Parse colon separated string and print
# each item on separated line
#
# Example:
#    $ parse_path_colon_sep a:b
#    a
#    b
parse_path_colon_sep() {
  local IFS=$'\n' my_input_str="$1"
  # shellcheck disable=SC2046
  realpath $(tr ':' '\n' <<< "$my_input_str")
}

# List gcc environment variables
# NOTE:
#    -v make gcc print on stderr
gccenv() {
  { echo | gcc -E -v - >/dev/null; } 2>&1
}

# Print specific variable of gcc
parse_gcc_var() {
  local var_name="$1" my_paths
  my_paths=$(gccenv | grep "${var_name}" | cut -d= -f2)
  parse_path_colon_sep "${my_paths}" | sort | uniq
}

# Print LIBRARY_PATH of gcc
gcclib() {
  parse_gcc_var LIBRARY_PATH
}

# Print COMPILER_PATH of gcc
gccpath() {
  parse_gcc_var COMPILER_PATH
}

# Print default include paths
gccinc() {
  echo | gcc -Wp,-v - -fsyntax-only
}

lssh() {
  ps -ef | command grep "[s]sh.*pts"
}

# Make path for each argument and cd into the last path
mkcd() {
  # shellcheck disable=SC2164
  command mkdir -p "$@" && cd "$_"
}

if alias which >/dev/null 2>&1; then
  # which command on Debian-based distros lack support for long options
  if which -h >/dev/null 2>&1; then
    which() {
      { alias; declare -f; } \
      | command which --tty-only --read-alias --read-functions --show-tilde --show-dot
    }
  fi
fi

if m_check_exist xclip; then
  # A shortcut function that simplifies usage of xclip.
  # - Accepts input from either stdin (pipe), or params.
  # ------------------------------------------------
  copy() {
    # If no tty, data should be available on stdin
    if ! [[ "$( tty )" == /dev/* ]]; then
      input="$(< /dev/stdin)"
    # Else, fetch input from params
    else
      input="$*"
    fi
    if [ -z "$input" ]; then  # If no input, print usage message.
      echo "Copies a string to the clipboard."
      echo "Usage: cb <string>"
      echo "       echo <string> | cb"
      return 1
    fi

    local _scs_col="\e[0;32m" _wrn_col='\e[1;31m'

    # Check user is not root (root doesn't have access to user xorg server)
    if [[ "$USER" == "root" ]]; then
      echo -e "$_wrn_col""Must be regular user (not root) to copy a file to the clipboard.\e[0m"
      return 1
    fi
    # Copy input to clipboard
    echo -n "$input" | xclip -selection c
    # Print status.
    echo -e "$_scs_col""Copied to clipboard:\e[0m"
  }
fi

# -- Aliases ---------------------------------------------------------------------

# Make colors to ls command
[[ -x /usr/bin/dircolors ]] && eval "$(dircolors -b)"

case "$(m_get_shell_type)" in
bash)
  alias chi='history -c'
  ;;
zsh)
  # https://wiki.archlinux.org/index.php/zsh#Help_command
  autoload -Uz run-help
  alias help='run-help'
  ;;
esac

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias buildtype='gcc -dumpmachine' # or make --version; bash --version; uname -o -m
alias cd-='cd -'
alias cd..='cd ..'
alias cdroot='cd "$(git root)"'
alias cp='cp -iv'

if m_check_exist ctags; then
  # Use "ctags --list-kinds=c" to list all kinds
  alias cproto='ctags --sort=no -x --c-kinds=fp'
fi

alias dd='dd status=progress'
alias df='df -h'
# Only diffutils v3.4+ includes the --color option
# CentOS 7 has diffutils 3.3
if diff --color 2>&1 | grep 'missing operand' >/dev/null 2>&1; then
  alias diff="diff --unified --color"
fi
alias du='du -sch'
alias fail='journalctl -p 3 -xb'
alias free='free -h'
alias g++='g++ -Wall -Wpedantic -Wextra -Weffc++ -masm=intel' #-fno-stack-protector
alias gcc='gcc -masm=intel'
alias gccn='gcc -Wfatal-errors -std=gnu11 -Wall -Wextra' # -pedantic #-fno-stack-protector
alias gccex='gcc -Wfatal-errors -m32 -fno-stack-protector -Wl,-z,norelro -z execstack -g'
alias gdb='gdb -q'
alias grep="grep --color"
m_check_exist hd || alias hd='hexdump -C'
alias l='ls -CF'
alias la='ls -AF'
alias lh='ls -dF .??*'
alias ll='ls -lF'

# Detect which `ls` flavor is in use
my_ls="ls -h --group-directories-first"
if ls --color >/dev/null 2>&1; then # GNU ls support colors
  alias ls="$my_ls --color"
elif ls --G >/dev/null 2>&1; then # BSD ls
  alias ls="$my_ls -G"
else
  alias ls="$my_ls"
fi
unset my_ls

alias lsblk='lsblk -o name,mountpoint,label,size,uuid'
alias ln='ln -iv'
alias mkdir='mkdir -pv'
alias mv='mv -iv'
alias nc='nc -v'
alias objdump='objdump -M intel'

if m_check_exist pip; then
  alias gpip='PIP_REQUIRE_VIRTUALENV="" pip '
  alias gpip3='PIP_REQUIRE_VIRTUALENV="" pip3 '
fi

alias py='python'
alias py2='python2'
alias py3='python3'
#alias rot13='tr "[A-Za-z]" "[N-ZA-Mn-za-m]"'
alias rm='rm -I'
alias shutdown='shutdown now'
#alias ssh-keygen='ssh-keygen -E md5 -lf'
alias sshpw='ssh -o PreferredAuthentications=password -o PubkeyAuthentication=no'
alias sudo='sudo '
#alias synctime='ntpd -qg'  # install ntp package
alias urldecode='python3 -c "import sys, urllib.parse as ul; print(ul.unquote(sys.argv[1]))"'
alias vi='vim'
alias wifiscan='nmcli device wifi rescan'
alias wifils='nmcli device wifi list'
#alias wifipasswod='sudo grep -r "^psk" /etc/NetworkManager/system-connections/'
#alias whois='whois -H --verbose'

# I think I can forget
# ```bash
# cmp -l file file2 | gawk '{printf "%08X %02X %02X\n", $1, strtonum(0$2), strtonum(0$3)}'
# or
# radiff2 file file2
# ```

alias suspend='systemctl suspend'
#if [[ -x /usr/bin/xflock4 ]]; then
#  alias suspend='xflock4 && systemctl suspend'
#fi

if m_check_exist rasm2; then
  alias asm32='rasm2 -a x86 -b 32'
  alias asm64='rasm2 -a x86 -b 64'
  alias disasm32='asm32 -D'
  alias disasm64='asm64 -D'
elif m_check_exist nasm; then
  # Usage: _assembly 32 'xor eax, eax; mov ebx, eax;'
  _assembly() {
    local infile='.nasm.s'
    local outfile='.nasm.bin'
    local bits="$1"
    local asm="$2"
    printf 'BITS %d\n%s\n' "$bits" "$asm" > "$infile" \
    && nasm "$infile" -o "$outfile" \
    && ndisasm -b "$bits" "$outfile"
  }

  alias asm32='_assembly 32'
  alias asm64='_assembly 64'
fi

if m_check_exist fuser; then
  # Usage: findport 123
  # find pid base on tcp port
  findport() {
    fuser --verbose --namespace tcp "$1"
  }
  alias lsport='ss --processes --all --tcp'
fi

# Terminal browser Elinks
if m_check_exist elinks; then
  alias elinks='elinks --no-connect'
fi

if m_check_exist pngcheck; then
  alias pngcheck='pngcheck -vv'
fi

# for zathura
if m_check_exist zathura; then
  alias zathura='zathura --fork'
fi

# for evince
if m_check_exist evince; then
  evince() {
    (command evince "$@" & )
  }
fi

# for audacious
if m_check_exist audacious; then
  audacious() {
    (command audacious "$@" & )
  }
fi

# Alias for each distribution {{{
# See more https://wiki.debian.org/ReduceDebian
#clrdesktop() {
#  echo "Clearing non English part in .desktop files ..."
#  if [[ -d "/usr/share/help" ]]; then
#    find /usr/share/applications/ -type f -iname '*\.desktop' -exec sudo sed -i "/]=/d" {} +
#  fi
#}

#clrhelp() {
#  echo "Clearing non-English help files ..."
#  if [[ -d "/usr/share/help" ]]; then
#    find "/usr/share/help" -maxdepth 1 $( echo "! -path /usr/share/help"{/C,/en_GB,} ) -type d -exec sudo rm -Irf {} +
#  fi
#}

#clrlocale() {
#  echo "Clearing non-English locale files ..."
#  find "/usr/share/locale" -maxdepth 1 $( echo "! -path /usr/share/locale"{/en,/en_US,/en_GB,/en\@quot,} ) -type d -exec sudo rm -Ifr {} +
#}

#clrman() {
#  echo "Clearing non-standard man files ..."
#  find "/usr/share/man" -maxdepth 1 $( echo "! -path /usr/share/man"{/man0,/man1,/man2,/man3,/man4,/man5,/man6,/man7,/man8,/mann,} ) -type d -exec sudo rm -Ifr {} +
#}

# Alias that depends on Linux distro
# Note:
#   Use [[ -x program ]] to test to assure that these programs are actually
#   executable and are the wanted program.
#
# Test for Debian variants
if [[ -x /usr/bin/dpkg ]]; then
  # Perform a simulation of the whole process by:
  #apt-get clean --dry-run
  alias aptshow='apt-cache show' # or `apt show` or `dpkg --print-avail`
  alias dpkglist='dpkg --listfiles' # List files from installed package
  #alias apts='apt-cache search'
  #alias lsapt='apt list --installed'

  #clrapt() {
  #  echo "Clearing apt cache ..."
  #  sudo apt-get clean
  #}
# Arch Linux
elif [[ -x /bin/pacman ]]; then
  #alias keepping='ping login.net.vn &> /dev/null &'
  alias pacman="pacman --color=auto"
  alias update-grub='grub-mkconfig -o /boot/grub/grub.cfg'
  alias wifioff='nmcli radio wifi off'
  alias wifion='nmcli radio wifi on'
  clrjournal() {
    echo "Clearing journal files ..."
    command sudo rm -rf /var/log/journal
  }

  clrpac() {
    echo "Clearing pacman cache ..."
    # remove all packages except for the latest three package versions
    sudo paccache -rvk3
  }
# for CentOS, RedHat, Fedora
elif [[ -x /usr/bin/yum ]]; then
  clryum() {
    echo "Clearing yum cache ..."
    command sudo rm -Ifr /var/cache/yum
  }
fi
