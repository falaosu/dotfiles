" ~/.vimrc file

if !has('nvim')
  " Normally we use vim-extensions. If you want true vi-compatibility
  " remove the following line.
  " Place it first as it changes any settings below.
  set nocompatible
endif

" vim-plug doesn't work with fish shell
if &shell =~# 'fish$'
  if executable('zsh')
    set shell=zsh
  elseif executable('bash')
    set shell=bash
  else
    set shell=sh
  endif
endif

" Use `vim "+runtime syntax/colortest.vim"` to test vim color
"set t_Co=256

" See <https://neovim.io/doc/user/term.html>
if exists('+termguicolors')
  if $TERM =~ '^\(rxvt\|screen\|interix\|putty\)\(-.*\)\?$'
      set notermguicolors
    elseif $TERM =~ '^\(tmux\|iterm\|vte\|gnome\)\(-.*\)\?$'
      set termguicolors
    elseif $TERM =~ '^\(xterm\)\(-.*\)\?$'
      if $XTERM_VERSION != '' || $KONSOLE_PROFILE_NAME != '' || $VTE_VERSION != ''
        set termguicolors
      endif
  endif
endif

" Switch syntax highlighting on when the terminal has colors or when using the
" GUI (which always has colors).
if &t_Co > 2 || has("gui_running")
  syntax enable      " enable syntax highlighting
endif

" For Win32 GUI, remove 't' flag from 'guioptions': no tearoff menu entries.
if has('win32')
  set guioptions-=t
endif

" Load indentation rules and plugins according to the detected filetype
filetype plugin indent on
set formatoptions=tcqj

" With a map leader it is possible to do extra key combinations
" like <leader>w saves the current file
" The mapleader has to be set before vundle starts loading all
" the plugins.
let mapleader   = ','
let g:mapleader = ','

" NOTE: plugins/themes/colorschemes are not activated before `plug#end`.
" vim-plug {{{
  " Specify a directory for plugins
  call plug#begin('~/.vim/plugged')

  Plug 'cespare/vim-toml'
  Plug 'rust-lang/rust.vim'
  Plug 'bogado/file-line'

  Plug 'junegunn/fzf'
  Plug 'junegunn/fzf.vim'
  Plug 'tpope/vim-sleuth'

  if has('nvim')
    Plug 'neoclide/coc.nvim', {'branch': 'release'}
  endif

  " Initialize plugin system
  call plug#end()
" }}}

" Environment {{{
  " If using a dark background within the editing area and syntax
  " highlighting turn on this option as well
  set background=dark
  set history=10000   " maximum of command history
  "set autowrite       " Automatically save before commands like :next and :make

  set timeout          " time out for mappings
  set timeoutlen=1000  " wait up to 1000ms after <mapleader>
  set ttimeout         " time out for key codes
  set ttimeoutlen=50 " time to wait after ESC for special key

  " modelines have historically been a source of security/resource
  " vulnerabilities -- disable by default, even when 'nocompatible' is set
  set nomodeline

  " disable warning when editing file in read-only mode
  set noreadonly

  " Linebreak on 500 characters
  set linebreak
  set textwidth=500

  "set autoread # reload file changed outside
  " This makes vim act like all other editors, buffers can
  " exist in the background without being in a window.
  " http://items.sjbach.com/319/configuring-vim-right
  set hidden          " remember undo after quitting

  " Turn off swap files since most stuff is in SVN, git et.c anyway...
  set noswapfile
  set nobackup
  set nowritebackup

  " system settings
  set lazyredraw           " no redraws in macros (good performance config)
  "set confirm              " get a dialog when :q, :w, or :wq fails
  " remember copy registers after quitting in the .viminfo file -- 20
  " jump links, regs up to 500 lines'
  "set viminfo='20,\"500
  set guicursor=a:blinkon0 " Disable cursor blink
  " Disable auto append EOL on save in binary files
  set noeol
  "set nofixeol
  " No annoying sound on errors
  set noerrorbells novisualbell t_vb=
" }}}

" Encoding {{{
  set encoding=utf-8
  set ttyfast " send more characters for redraws
  set fileformat=unix       " file mode is unix
  "set fileformats=unix,dos  " only detect unix file format, displays that ^M with dos files
" }}}

" Colors {{{
  " Popup menu
  highlight       Pmenu           ctermbg=Black     ctermfg=Gray
  highlight       PmenuSel        ctermbg=DarkGray  ctermfg=Yellow
  highlight       PmenuSbar       ctermbg=Blue      ctermfg=DarkGray
  if has('nvim')
    " FIXME: Without this setting the CocFloating color is unreadable
    " See <https://users.rust-lang.org/t/coc-nvim-completion-pane-is-hard-to-read/41466>
    highlight link  CocFloating     markdown
  endif
  highlight User1 ctermbg=Brown     ctermfg=White
  highlight User2 ctermbg=Red       ctermfg=DarkRed
  highlight User3 ctermbg=Blue      ctermfg=White
  highlight User4 ctermbg=White     ctermfg=DarkMagenta
  highlight User5 ctermbg=Green     ctermfg=DarkRed
  highlight User6 ctermbg=White     ctermfg=Black
  highlight User7 ctermbg=Green     ctermfg=Red
  highlight User8 ctermbg=Cyan      ctermfg=LightRed
  highlight User9 ctermbg=Magenta   ctermfg=Yellow
  highlight User0 ctermbg=LightGray ctermfg=White
" }}}

" Vim UI {{{
  set number                                            " Show line numbers
  "set relativenumber
  "set cursorline                                        " highlight current line
  set cmdheight=2                                       " Height of the command bar
  set showmode                                          " Show mode: normal,insert,command,help mode
  " Show file in Terminal titlebar but restore old one when quitting
  set title
  set titleold=
  set nostartofline
  if has("cmdline_info")
    set ruler                                           " Always show current position in status bar
    "set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " a ruler on steroids
    set showcmd                                         " Show (partial) command in the last line of the screen
  endif

  set list listchars=tab:>-,trail:-,nbsp:+

  " FIXME: rewrite like sublime text or vim-airline
  if has("statusline")
    set laststatus=2   " use 2 lines for the status bar
    " Format the status line
    set statusline=
    set statusline+=%1*\[%n]                              " buffer number
    set statusline+=%1*\ %<%F\                            " Filepath
    set statusline+=%6*\ %{(&fenc!=''?&fenc:&enc)}\       " encoding
    set statusline+=%3*\ %y[%{&ff}]                       " filetype, file format (dos/unix..)
    set statusline+=%3*%m%r%w%h\                          " Options: modified,readonly,help buffer,Preview window flag
    set statusline+=%4*\ %{&paste?'[paste]':'[nopaste]'}\ " warning if paste is set
    set statusline+=%5*%=                                 " switch to the right side
    set statusline+=%5*\ Line:\ %4l/%L\                   " current line/total lines (%)
    set statusline+=%6*\ Column:\ %-4v                    " column number
  endif

  " Show as much as possible of the last line in the window rather
  " than a column of "@", which is the default behavior.
  set display="lastline,msgsep"
  " Configure backspace so it acts as it should act
  set backspace=indent,eol,start " Allow backspacing over everything in insert mode
  set shortmess="filnxtToOF"
  set whichwrap=b,s,h,l,<,>,[,]  " backspace and cursor keys wrap to
" }}}

" Indentation {{{
  set nowrap           " do not wrap lines
  set autoindent       " indent at the same level of the previous line
  set smartindent      " smart auto indenting
  set smarttab         " smart tab handling for indenting
  " FIXME: Honors plugin choices instead of overriding them
  "set shiftwidth=2     " operation >> indents 2 columns; << unindents 2 columns
  "set softtabstop=2    " insert/delete 2 spaces when hitting a TAB/BACKSPACE
  "set tabstop=8        " a hard TAB displays as 8 columns
  "set expandtab        " insert spaces when hitting TABs
  set pastetoggle=<F3> " paste mode to avoid autoindent
" }}}

" Automatic commands {{{
  " NOTE: use `augroup` not not duplicate `autocmd` each time the config loaded
  " Only do this part when compiled with support for auto-commands.
  if exists('+autocmd')
    augroup my_buf_settings
      autocmd! " clear this group
      " Jump to the last position when reopening a file
      "autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
      " remove whitespaces on save
      "autocmd BufWritePre *.php,*.md,*.vim,*.txt,*.js,*.py,*.sh,*.c,*.cpp,*.h,*.hpp,*.java,*.sh :call TrimTrailingWhiteSpace()
      " Disable visualbell
      autocmd GUIEnter * set visualbell t_vb=
      " Run checktime in buffers, but avoiding the "Command Line" (q:) window
      autocmd CursorHold * if getcmdwintype() == '' | checktime | endif
    augroup END

    augroup my_lang_settings
      autocmd! " clear this group
      " But do wrap on these types of files...
      autocmd FileType java setlocal noexpandtab
      autocmd FileType html setlocal wrap
      "autocmd BufEnter Makefile setlocal noexpandtab shiftwidth=4
      "autocmd BufNewFile,BufRead CMakeLists.txt setlocal filetype=cmake
      "autocmd FileType markdown setlocal wrap
      autocmd FileType php setlocal
      autocmd FileType python setlocal wrap formatoptions+=croq tabstop=4 softtabstop=4 shiftwidth=4 textwidth=79
      autocmd FileType perl setlocal wrap
      autocmd FileType ruby setlocal wrap
      " XXX: vim is slow with large math text files
      autocmd FileType tex setlocal nocursorline | :NoMatchParen
      " FIXME: Disable to find if it causes folding on saving and reload
      "autocmd FileType rust setlocal foldmethod=syntax formatoptions+=croq tabstop=4 softtabstop=4 shiftwidth=4 textwidth=120
      "autocmd FileType vim setlocal foldenable foldmethod=marker foldlevel=0 modelines=1
      autocmd FileType xml setlocal noexpandtab shiftwidth=4
    augroup END
  endif
" }}}

" Syntax highlight
" Default highlight is better than polyglot
"let g:polyglot_disabled = ['python']
"let python_highlight_all = 1

" Folds {{{
  set nofoldenable        " dont fold by default
  set foldlevel=99
  " XXX: do not set foldmethod by default, it causes folding on saving or reload
  "set foldmethod=indent " fold based on indent
  "set foldnestmax=3     " deepest fold is 3 levels
  "set foldcolumn=1      " Add a bit extra margin to the left
  " Use space to open/closes folds and set foldenable
  nnoremap <space> za
  " Turn on fold
  noremap <leader>f :set foldenable<cr>
" }}}

" Completion {{{
  set wildmenu            " enable CTRL-N and CTRL-P to scroll command-line completions
  set wildmode=list:longest
  " Ignore compiled files
  set wildignore=*.o,*.obj,*.bak,*.exe,*.py[co],*.swp,*~,.svn
" }}}

" Mouse and scrolling {{{
  set mouse=n         " use mouse in normal mode
  set mousemodel=popup " do not change cursor when right click
  "set mouse=a         " Enable mouse usage (all modes: normal,insert,command,help mode)
  " 7 lines to the cursor - when moving using j/k
  set scrolloff=7
  set sidescrolloff=15
  set sidescroll=1
" }}}

" Search {{{
  set hlsearch        " highlight search (very useful!)
  set incsearch       " search incrementally (search while typing)
  set ignorecase      " Do case insensitive matching
  set smartcase       " but do case sensitive if you type uppercase characters
  set gdefault        " /g flag on :s substitutions by default
  set magic           " For regular expression, change the way backslashes
                      " are used in search patterns
  set showmatch       " highlight matching [{()}]
  set matchtime=2     " show matching bracket for 0.2 seconds
  set matchpairs+=<:> " specially for html
" }}}

" Key mappings/bindings {{{
  " Making it so ; works like : for commands. Saves typing and
  " eliminates :W style typos due to lazy holding shift.
  nnoremap ; :
  nnoremap <C-p> :FZF<cr>
  noremap <leader>h :%!xxd<cr>:set syntax=xxd<cr> " for binary file
  noremap <leader>u :%!xxd -r<cr>:syntax enable<cr> " to revert after xxd
  nmap <leader>w :w!<cr> " fast saving
  nmap <leader>q :q<cr>  " quit file
  nmap <leader>Q :q!<cr> " quit anyway
  " split the current window horizontally
  nnoremap <leader>- :sp<cr>
  " split the current window vertically
  nnoremap <leader>\| :vs<cr>
  " Fast set wrapping
  nmap <leader>r :set wrap<cr>
  " sudo write when no have enough privilege
  nmap <leader>W :w !sudo tee % > /dev/null<cr>
  " toggle spell-checking with F6 (same as Sublime Text)
  nmap <F6> :setlocal spell! spelllang=en_us<cr>
  " turn off search highlight
  nnoremap <leader><space> :nohlsearch<cr>
  " Move up/down editor lines, rather than next line in file
  nnoremap j gj
  nnoremap k gk
  "nnoremap <silent> <Esc> :nohlsearch<Bar>:echo<cr>
  " Search mappings: These will make it so that going to the next one in a
  " search will center on the line it's found in.
  nnoremap n nzzzv
  nnoremap N Nzzzv
  " Tab back and forth between those files
  nnoremap <TAB> :bnext<cr>
  nnoremap <S-TAB> :bprevious<cr>
  " close only one buffer
  nnoremap <leader>c :bd<cr>
  " no one is really happy until you have this shortcuts
  "cnoreabbrev W! w!
  "cnoreabbrev Q! q!
  "cnoreabbrev Qall! qall!
  "cnoreabbrev Wq wq
  "cnoreabbrev Wa wa
  "cnoreabbrev wQ wq
  "cnoreabbrev WQ wq
  "cnoreabbrev W w
  "cnoreabbrev Q q
  "cnoreabbrev Qall qall
  "cmap Tabe tabe
  " Switching windows
  noremap <C-j> <C-w>j
  noremap <C-k> <C-w>k
  noremap <C-l> <C-w>l
  noremap <C-h> <C-w>h
  " Vmap for maintain Visual Mode after shifting > and <
  vnoremap < <gv
  vnoremap > >gv
  " Yank to the end of the line, to be consistent with C and D.
  nnoremap Y y$

  inoremap " ""<left>
  inoremap ' ''<left>
  inoremap ( ()<left>
  inoremap [ []<left>
  inoremap { {}<left>
  inoremap {<cr> {<cr>}<ESC>O
  inoremap {;<cr> {<cr>};<ESC>O

  nnoremap <F5>     :call TrimTrailingWhiteSpace()<cr>
  vnoremap <F5>     :call TrimTrailingWhiteSpace()<cr>

  inoremap <C-a>        <esc>I
  inoremap <C-e>        <End>

  " Search for selected text, forwards or backwards.
  " NOTE:
  "     <C-R>/ is the contents of the last search pattern
  "            (see http://vimdoc.sourceforge.net/htmldoc/cmdline.html#c_CTRL-R)
  vnoremap <silent> * :<C-U>call GetVisualSelectedText('/')<cr>/<C-R>/<cr>
  vnoremap <silent> # :<C-U>call GetVisualSelectedText('?')<cr>?<C-R>/<cr>

  " Use ":reg" to view content of all vim registers
  if executable('xsel')
    nnoremap <leader>y     :w !xsel -i -b<cr><cr>
    vnoremap <leader>y     :'<,'>w !xsel -i -b<cr><cr>
     noremap <leader>p     :r !xsel -o -b<cr><cr>
    nnoremap <leader>d     :d<cr>""w !xsel -i -b <cr><cr>
    vnoremap <leader>d     :'<,'>d<cr>""w !xsel -i -b <cr><cr>
    nnoremap <leader>x     :x<cr>""w !xsel -i -b <cr><cr>
    vnoremap <leader>x     :'<,'>x<cr>""w !xsel -i -b <cr><cr>
  endif
" }}}

" Helper functions {{{
  "
  " Write a Vim script manual: http://vimdoc.sourceforge.net/htmldoc/usr_41.html
  "

  " strips trailing whitespace at the end of all of lines
  fun! TrimTrailingWhiteSpace()
    let l:save = winsaveview()
    %s/\s\+$//e
    call winrestview(l:save)
  endfun

  " Escape string in selected text
  " http://vim.wikia.com/wiki/Search_for_visually_selected_text
  fun! GetVisualSelectedText(cmd)
    let l:old_reg=getreg('"')
    let l:old_regtype=getregtype('"')
    norm! gvy
    let l:escape_range = '\.*$^~['
    let l:pattern_esc = escape(@", a:cmd.l:escape_range)
    let l:pattern = substitute(l:pattern_esc, '\_s\+', '\\_s\\+', 'g')
    norm! gV
    let @/ = l:pattern
    call setreg('"', l:old_reg, l:old_regtype)
  endfun
" }}}

" Comments {{{
  noremap gcc :call CommentLines()<cr>
  noremap gcu :call UncommentLines()<cr>

  " Improved from https://github.com/BurntSushi/dotfiles/blob/e5c72a924e0d163e130692d46ff7f4d9188307bf/.config/nvim/include/comment.vim
  let s:comment_leaders = {
    \ 'javascript':     '//',
    \ 'c':              '//',
    \ 'cpp':            '//',
    \ 'java':           '//',
    \ 'objc':           '//',
    \ 'scala':          '//',
    \ 'go':             '//',
    \ 'rust':           '//',
    \
    \ 'php':            '#',
    \ 'ruby':           '#',
    \ 'sh':             '#',
    \ 'make':           '#',
    \ 'python':         '#',
    \ 'perl':           '#',
    \
    \ 'tex':            '%',
    \
    \ 'vim':            '"',
    \ }

  function! CommentLines()
    let l:leader = get(s:comment_leaders, &filetype, '')
    if l:leader != ''
      exe ':s/^\(\s*\)/\1' . escape(l:leader, '/') . ' /e'
    else
      echoerr 'No command leader for this filetype'
    endif
  endfun

  function! UncommentLines()
    let l:leader = get(s:comment_leaders, &filetype, '')
    if l:leader != ''
      exe ':s/^\(\s*\)' . escape(l:leader, '*$.^/') . '\s*/\1/e'
    else
      echoerr 'No command leader for this filetype'
    endif
  endfun
" }}}

if has('nvim')
  if filereadable(stdpath('config') . '/local.vim')
    exe 'source ' . stdpath('config') . '/local.vim'
  endif
else
  if filereadable(expand("~/.vim/vimrc.local"))
    source ~/.vim/vimrc.local
  endif
endif
